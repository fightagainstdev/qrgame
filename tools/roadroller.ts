import CleanCSS from "clean-css";
import htmlMinify, { Options as HtmlMinifyOptions } from "html-minifier-terser";
import {
  Input,
  InputAction,
  InputType,
  Packer,
  PackerOptions,
  defaultSparseSelectors,
} from "roadroller";
import { OutputAsset, OutputChunk } from "rollup";
import { IndexHtmlTransformContext, Plugin } from "vite";
import { escapeRegExp } from "./utils";
import { writeFileSync } from "node:fs";

export type RoadrollerOptions = PackerOptions;

const OPTIMIZE = 3;
export const defaultRoadrollerOptions: RoadrollerOptions = {
  allowFreeVars: true,
  // dynamicModels: 1,
  // precision: 16,
  maxMemoryMB: 512,
  // sparseSelectors: defaultSparseSelectors(24),
};

export type { HtmlMinifyOptions };

export const defaultHtmlMinifyOptions: HtmlMinifyOptions = {
  includeAutoGeneratedTags: true,
  removeAttributeQuotes: true,
  removeComments: true,
  removeRedundantAttributes: true,
  removeScriptTypeAttributes: true,
  removeStyleLinkTypeAttributes: true,
  sortClassName: true,
  useShortDoctype: true,
  collapseWhitespace: true,
  collapseInlineTagWhitespace: true,
  removeEmptyAttributes: true,
  removeOptionalTags: true,
  sortAttributes: true,
};

/**
 * Creates the Roadroller plugin that crunches the JS and CSS.
 *
 * Based on Rob Louie's recommendations:
 * See: https://github.com/codyebberson/js13k-starter-2022/pull/1
 *
 * @returns The roadroller plugin.
 */
export function roadrollerPlugin(
  roadrollerOptions: RoadrollerOptions = defaultRoadrollerOptions,
  htmlMinifyOptions: HtmlMinifyOptions = defaultHtmlMinifyOptions
): Plugin {
  const fullRoadrollerOptions = roadrollerOptions;
  const fullHtmlMinifyOptions = htmlMinifyOptions;
  return {
    name: "vite:roadroller",
    transformIndexHtml: {
      handler: async (
        html: string,
        ctx?: IndexHtmlTransformContext
      ): Promise<string> => {
        // Only use this plugin during build
        if (!ctx || !ctx.bundle) {
          return html;
        }

        let result = html;

        const bundleKeys = Object.keys(ctx.bundle);

        const cssKey = bundleKeys.find((key) => key.endsWith(".css"));
        if (cssKey) {
          result = embedCss(result, ctx.bundle[cssKey] as OutputAsset);
          delete ctx.bundle[cssKey];
        }

        result = await htmlMinify.minify(result, fullHtmlMinifyOptions);

        const jsKey = bundleKeys.find((key) => key.endsWith(".js"));
        if (jsKey) {
          result = await embedJs(
            result,
            ctx.bundle[jsKey] as OutputChunk,
            fullRoadrollerOptions
          );
          delete ctx.bundle[jsKey];
        }

        return result;
      },
    },
  };
}

/**
 * Transforms the given JavaScript code into a packed version.
 * @param html The original HTML.
 * @param chunk The JavaScript output chunk from Rollup/Vite.
 * @returns The transformed HTML with the JavaScript embedded.
 */
async function embedJs(
  html: string,
  chunk: OutputChunk,
  options: RoadrollerOptions
): Promise<string> {
  const scriptTagRemoved = html.replace(
    new RegExp(`<script[^>]*?${escapeRegExp(chunk.fileName)}[^>]*?></script>`),
    ""
  );
  const htmlInJs = `document.write(\`${scriptTagRemoved}\`);${chunk.code.trim()}`;
  const bypassRoadRoller = false;
  writeFileSync("build/minimified.js", htmlInJs);
  if (bypassRoadRoller) {
    return `<script>${htmlInJs}</script>`;
  }
  const inputs: Input[] = [
    {
      data: htmlInJs,
      type: "js" as InputType,
      action: "eval" as InputAction,
    },
  ];
  // console.info(inputs);
  const packer = new Packer(inputs, options);
  let startSize = inputs[0].data.length;
  let bestSize = 0;
  let bestIterations = 0;
  process.stdout.write("\n");
  await packer.optimize(OPTIMIZE, (p) => {
    if (p.bestUpdated) {
      bestSize = p.bestSize;
      ++bestIterations;
      process.stdout.write("working... " + p.bestSize + "\r");
    }
  });
  const { firstLine, secondLine } = packer.makeDecoder();
  const resultHtml = `<script>${firstLine}${secondLine}</script>`;
  console.info("Start Size: " + startSize);
  console.info("Best Size: " + bestSize);
  console.info("Roller good iterations: " + bestIterations);
  console.info("Final (+decoder): " + resultHtml.length);
  writeFileSync("build/roadroller.html", resultHtml);
  return resultHtml;
}

/**
 * Embeds CSS into the HTML.
 * @param html The original HTML.
 * @param asset The CSS asset.
 * @returns The transformed HTML with the CSS embedded.
 */
function embedCss(html: string, asset: OutputAsset): string {
  const reCSS = new RegExp(
    `<link [^>]*?href="[./]*${escapeRegExp(asset.fileName)}"[^>]*?>`
  );
  const code = `<style>${
    new CleanCSS({ level: 2 }).minify(asset.source as string).styles
  }</style>`;
  return html.replace(reCSS, code);
}
